package net.consensys.mahuta.client.java;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import org.apache.commons.io.IOUtils;

import lombok.extern.slf4j.Slf4j;
import net.consensys.mahuta.core.Mahuta;
import net.consensys.mahuta.core.exception.MahutaException;


/**
 * Mahuta Java Client
 *
 * @author Gregoire Jeanmart <gregoire.jeanmart@consensys.net>
 */
@Slf4j
public class MahutaClient {

    private static final String ID_ATTRIBUTE = "_id";
    private static final String HASH_ATTRIBUTE = "__hash";

    private final Mahuta mahuta;


    /* *********************************************
     * Constructor
     * *********************************************/




    /* *********************************************
     * Public methods
     * *********************************************/

    /**
     * Store a file
     *
     * @param filePath Content (File path)
     * @return IPFS hash
     * @throws MahutaException
     */
    public String store(String filePath) throws MahutaException {

        try(FileInputStream input = new FileInputStream(filePath)) {
            return this.store(input);

        } catch (IOException e) {
            throw new MahutaException(e);
        } 
    }

    /**
     * Store a byte array
     *
     * @param is Content (Input stream)
     * @return IPFS hash
     * @throws MahutaException
     */
    public String store(InputStream is) throws MahutaException {
        try {
            return mahuta.index

        } catch (IOException e) {
            throw new MahutaException(e);
        }
    }

    /**
     * Index an IPFS hash with the minimum required arguments.
     * This  funtion indexes an IPFS hash into an index and return an autogenerated id identifying the content in the index
     *
     * @param indexName Index name
     * @param hash      IPFS hash
     * @return IdAndHash  Unique Identifier of the content in the index and IPFS Hash
     * @throws MahutaException
     */
    public IdAndHash index(String indexName, String hash) throws MahutaException {
        return this.index(indexName, hash, null);
    }

    /**
     * Index an IPFS hash
     * This  funtion indexes an IPFS hash into an index with a given ID identifying the content in the index
     *
     * @param indexName Index name
     * @param hash      IPFS hash
     * @param id        Unique identifier of the content in the index
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(String indexName, String hash, String id) throws MahutaException {
        return this.index(indexName, hash, id, null);
    }

    /**
     * Index an IPFS hash
     * This  funtion indexes an IPFS hash into an index with a given ID identifying the content in the index
     * and the content type (MIMETYPE: application/json, ...)
     *
     * @param indexName   Index name
     * @param hash        IPFS hash
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @return IdAndHash  Unique Identifier of the content in the index and IPFS Hash
     * @throws MahutaException
     */
    public IdAndHash index(String indexName, String hash, String id, String contentType) throws MahutaException {
        return this.index(indexName, hash, id, contentType, new ArrayList<>());
    }

    /**
     * Index an IPFS hash
     * This  funtion indexes an IPFS hash into an index with a given ID identifying the content in the index,
     * the content type (MIMETYPE: application/json, ...) and a list of key/value attributes (metadata)
     *
     * @param indexName   Index name
     * @param hash        IPFS hash
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @param indexFields Attributes (key/value) to attach to the index document for the given hash and ID
     * @return IdAndHash  Unique Identifier of the content in the index and IPFS Hash
     * @throws MahutaException
     */
    public IdAndHash index(String indexName, String hash, String id, String contentType, Map<String, Object> indexFields)
            throws MahutaException {

        return this.index(indexName, hash, id, contentType, convert(indexFields));
    }

    /**
     * Index an IPFS hash
     * This  funtion indexes an IPFS hash into an index with a given ID identifying the content in the index,
     * the content type (MIMETYPE: application/json, ...) and a list of key/value attributes (metadata)
     *
     * @param indexName   Index name
     * @param hash        IPFS hash
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @param indexFields Attributes (key/value) to attach to the index document for the given hash and ID
     * @return IdAndHash  Unique Identifier of the content in the index and IPFS Hash
     * @throws MahutaException
     */
    public IdAndHash index(String indexName, String hash, String id, String contentType, List<IndexField> indexFields)
            throws MahutaException {

        IndexerResponse response = this.wrapper.index(createRequest(indexName, hash, id, contentType, indexFields));
        
        return IdAndHash.builder().hash(hash).id(response.getDocumentId()).build();
    }

    /**
     * Store and Index an IPFS hash with the minimum required arguments.
     * This funtion stores a content into IPFS and then indexes an IPFS hash into an index and return an autogenerated id identifying the content in the index
     *
     * @param file      Content (Input Stream)
     * @param indexName Index name
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(InputStream file, String indexName) throws MahutaException {
        return this.index(file, indexName, null);
    }

    /**
     * Store and Index an IPFS hash
     * This funtion stores a content into IPFS and then indexes an IPFS hash into an index  with a given ID identifying the content in the index
     *
     * @param file      Content (Input Stream)
     * @param indexName Index name
     * @param id        Unique identifier of the content in the index
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(InputStream file, String indexName, String id) throws MahutaException {
        return this.index(file, indexName, id, null);
    }

    /**
     * Store and Index an IPFS hash
     * This funtion stores a content into IPFS and then indexes an IPFS hash into an index  with a given ID identifying the content in the index and the content type
     *
     * @param file        Content (Input Stream)
     * @param indexName   Index name
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(InputStream file, String indexName, String id, String contentType) throws MahutaException {
        return this.index(file, indexName, id, contentType, new ArrayList<>());
    }

    /**
     * Store and Index an IPFS hash
     * This funtion stores a content into IPFS and then indexes an IPFS hash into an index  with a given ID identifying the content in the index,
     * the content type (MIMETYPE: application/json, ...) and a list of key/value attributes (metadata)
     *
     * @param file        Content (Input Stream)
     * @param indexName   Index name
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @param indexFields Attributes (key/value) to attach to the index document for the given hash and ID
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(InputStream file, String indexName, String id, String contentType,
                        Map<String, Object> indexFields) throws MahutaException {
        return this.index(file, indexName, id, contentType, convert(indexFields));
    }

    /**
     * This funtion stores a content into IPFS and then indexes an IPFS hash into an index  with a given ID identifying the content in the index,
     * the content type (MIMETYPE: application/json, ...) and a list of key/value attributes (metadata)
     *
     * @param file        Content (Input Stream)
     * @param indexName   Index name
     * @param id          Unique identifier of the content in the index
     * @param contentType Content Type (MIMETYPE)
     * @param indexFields Attributes (key/value) to attach to the index document for the given hash and ID
     * @return Unique Identifier of the content in the index
     * @throws MahutaException
     */
    public IdAndHash index(InputStream file, String indexName, String id, String contentType,
                        List<IndexField> indexFields) throws MahutaException {

        try {
            IndexerResponse response = this.wrapper.storeAndIndex(
                    IOUtils.toByteArray(file),
                    createRequest(indexName, null, id, contentType, indexFields)
            );
            
            return IdAndHash.builder().id(response.getDocumentId()).hash(response.getHash()).build();

        } catch (IOException e) {
            throw new MahutaException(e);
        }
    }

    /**
     * Return a document for a given hash
     *
     * @param indexName Index name
     * @param hash      IPFS hash
     * @return Content byte array
     * @throws MahutaException
     */
    public byte[] get(String indexName, String hash) throws MahutaException {
        return this.wrapper.fetch(indexName, hash);
    }

    /**
     * Return a document for a given Index Unique identifier
     *
     * @param indexName Index name
     * @param id        document Unique identifier
     * @return Content (metadata + payload)
     * @throws MahutaException
     */
    public MetadataAndPayload getById(String indexName, String id) throws MahutaException {
        Metadata metadata = this.getMetadataById(indexName, id);

        return MetadataAndPayload.builder()
                .metadata(metadata)
                .payload(this.get(indexName, metadata.getHash()))
                .build();
    }

    /**
     * Return a document for a given hash
     *
     * @param indexName Index name
     * @param hash      Document hash
     * @return Content (metadata + payload)
     * @throws MahutaException
     */
    public MetadataAndPayload getByHash(String indexName, String hash) throws MahutaException {
        Metadata metadata = this.getMetadataByHash(indexName, hash);

        return MetadataAndPayload.builder()
                .metadata(metadata)
                .payload(this.get(indexName, hash))
                .build();
    }

    /**
     * Return the content metadata (index, ID, content_type, hash and attributes)
     *
     * @param indexName Index name
     * @param id        Document Unique identifier
     * @return Metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Metadata getMetadataById(String indexName, String id) throws MahutaException {
        Query query = Query.newQuery().equals(ID_ATTRIBUTE, id);

        Page<Metadata> searchResult = this.wrapper.search(indexName, query, PageRequest.of(0, 1));
        if (searchResult.getTotalElements() == 0) {
            throw new NotFoundException("Content [indexName: " + indexName + ", id: "+ id + "] not found in the index");
        }

        return searchResult.getContent().get(0);
    }

    /**
     * Return the content metadata (index, ID, content_type, hash and attributes)
     *
     * @param indexName Index name
     * @param hash        document hash
     * @return Metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Metadata getMetadataByHash(String indexName, String hash) throws MahutaException {
        Query query = Query.newQuery().equals(HASH_ATTRIBUTE, hash);

        Page<Metadata> searchResult = this.wrapper.search(indexName, query, PageRequest.of(0, 1));
        if (searchResult.getTotalElements() == 0) {
            throw new NotFoundException("Content [indexName: " + indexName + ", hash: "+ hash + "] not found in the index");
        }

        return searchResult.getContent().get(0);
    }

    /**
     * Search all content metadata in the index with default pagination (limit 20)
     *
     * @param indexName Index name
     * @return Page of content metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Page<Metadata> search(String indexName) throws MahutaException {
        return this.search(indexName, null);
    }

    /**
     * Search content metadata with search criteria and default pagination (limit 20)
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @return Page of content metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Page<Metadata> search(String indexName, Query query) throws MahutaException {
        return this.search(indexName, query, null);
    }

    /**
     * Search content metadata with search criteria and pagination
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @param pageable  Pagination and Sorting
     * @return Page of content metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Page<Metadata> search(String indexName, Query query, Pageable pageable) throws MahutaException {
        return this.wrapper.search(indexName, query, pageable);
    }

    /**
     * Search content metadata with search criteria and pagination
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @param pageNo    Page no
     * @param pageSize  Page size
     * @return Page of content metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Page<Metadata> search(String indexName, Query query, int pageNo, int pageSize)
            throws MahutaException {
        return this.search(indexName, query, pageNo, pageSize, null, null);
    }

    /**
     * Search content metadata with search criteria, pagination and sorting
     *
     * @param indexName     Index name
     * @param query         Query with search criteria
     * @param pageNo        Page no
     * @param pageSize      Page size
     * @param sortAttribute Sorting attribute
     * @param sortDirection Sorting direction
     * @return Page of content metadata (index, ID, content_type, hash and attributes)
     * @throws MahutaException
     */
    public Page<Metadata> search(String indexName, Query query, int pageNo, int pageSize, String sortAttribute,
                                 Direction sortDirection) throws MahutaException {

        PageRequest pagination;
        if (sortAttribute == null || sortAttribute.isEmpty()) {
            pagination = PageRequest.of(pageNo, pageSize);
        } else {
            pagination = PageRequest.of(pageNo, pageSize, new Sort(sortDirection, sortAttribute));
        }

        return this.search(indexName, query, pagination);
    }

    /**
     * Search all content with default pagination and returns a content list page
     *
     * @param indexName Index name
     * @return Page of content (metadata + payload)
     * @throws MahutaException
     */
    public Page<MetadataAndPayload> searchAndFetch(String indexName) throws MahutaException {
        return this.searchAndFetch(indexName, null);
    }

    /**
     * Search content with search criteria and with default pagination, and returns a content list page
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @return Page of content (metadata + payload)
     * @throws MahutaException
     */
    public Page<MetadataAndPayload> searchAndFetch(String indexName, Query query) throws MahutaException {
        return this.searchAndFetch(indexName, query, null);
    }

    /**
     * Search content with search criteria, pagination and sorting and returns a content list page
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @param pageable  Pagination and Sorting
     * @return Page of content (metadata + payload)
     * @throws MahutaException
     */
    public Page<MetadataAndPayload> searchAndFetch(String indexName, Query query, Pageable pageable)
            throws MahutaException {
        Page<Metadata> search = this.wrapper.search(indexName, query, pageable);

        List<MetadataAndPayload> contentList = search.getContent().stream().map(m -> {
            try {
                return MetadataAndPayload.builder()
                        .metadata(m)
                        .payload(this.get(indexName, m.getHash()))
                        .build();
                
            } catch (MahutaException e) {
                log.error("Error while fetching " + m.getHash(), e);
                return null;
            }
        }).collect(Collectors.toList());

        // Apply the default pagination returned by the API if pagable is null
        pageable = Optional.ofNullable(pageable)
                .orElseGet(() -> PageRequest.of(search.getNumber(), search.getSize()));
        
        return new PageImpl<>(contentList, pageable, search.getTotalElements());
    }

    /**
     * Search content with search criteria, pagination and returns a content list page
     *
     * @param indexName Index name
     * @param query     Query with search criteria
     * @param pageNo    Page no
     * @param pageSize  Page size
     * @return Page of content (metadata + payload)
     * @throws MahutaException
     */
    public Page<MetadataAndPayload> searchAndFetch(String indexName, Query query, int pageNo, int pageSize)
            throws MahutaException {
        return this.searchAndFetch(indexName, query, pageNo, pageSize, null, null);
    }

    /**
     * Search content with search criteria, pagination and sorting and returns a content list page
     *
     * @param indexName     Index name
     * @param query         Query with search criteria
     * @param pageNo        Page no
     * @param pageSize      Page size
     * @param sortAttribute Sorting attribute
     * @param sortDirection Sorting direction
     * @return Page of content (metadata + payload)
     * @throws MahutaException
     */
    public Page<MetadataAndPayload> searchAndFetch(String indexName, Query query, int pageNo, int pageSize, String sortAttribute,
                                       Direction sortDirection) throws MahutaException {

        PageRequest pagination;
        if (sortAttribute == null || sortAttribute.isEmpty()) {
            pagination = PageRequest.of(pageNo, pageSize);
        } else {
            pagination = PageRequest.of(pageNo, pageSize, new Sort(sortDirection, sortAttribute));
        }

        return this.searchAndFetch(indexName, query, pagination);
    }

    /**
     * Create a new index
     *
     * @param index Index name
     * @throws MahutaException
     */
    public void createIndex(String index) throws MahutaException {
        this.wrapper.createIndex(index);
    }
    
    public void remove(String index, String id) throws MahutaException {
    	this.wrapper.removeById(index, id);
    }

    /**
     * Return the wrapper
     *
     * @return wrapper
     */
    public MahutaWrapper getWrapper() {
        return this.wrapper;
    }




    /* *********************************************
     * Private methods
     * *********************************************/

    /**
     * Convert a map<String, Object> to a list of IndexField (Key/Value pair)
     *
     * @param indexFields Map of data that need to be indexed against the document
     * @return A converted Map into a list of IndexField (Key/Value pair)
     */
    private static List<IndexField> convert(Map<String, Object> indexFields) {
        return indexFields.entrySet()
                .stream()
                .map(e -> new IndexField(e.getKey(), e.getValue()))
                .collect(Collectors.toList());
    }

    /**
     * Factory for a IndexerRequest
     *
     * @param indexName   Index name
     * @param hash        IPFS hash
     * @param id          Document ID
     * @param contentType Content Type
     * @param indexFields Index fields (key/value attribute)
     * @return IndexerRequest object
     */
    private static IndexerRequest createRequest(String index, String hash, String id, String contentType, List<IndexField> indexFields) {
        IndexerRequest request = new IndexerRequest();
        request.setIndex(index);
        request.setHash(hash);
        request.setDocumentId(id);
        request.setContentType(contentType);
        request.setIndexFields(indexFields);

        return request;
    }
    
    /**
     * 
     */
    private void initIndexes(String... indexes) {
        if(indexes != null && indexes.length > 0) {
            Arrays.asList(indexes)
                .stream()
                .forEach(index -> {
                    try {
                        wrapper.createIndex(index);
                    } catch (MahutaException e) {
                        log.error("Error while creating index {}", index, e);
                    }
                });
        }
    }

}
